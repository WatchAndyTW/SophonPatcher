/// Auto-generated by Anthropic Claude Sonnet 4

use std::fs::{self, File};
use std::io::{self, BufReader, Write};
use std::path::{Path, PathBuf};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ArchiveError {
    #[error("IO error: {0}")]
    Io(#[from] io::Error),
    #[error("ZIP error: {0}")]
    Zip(#[from] zip::result::ZipError),
    #[error("7z error: {0}")]
    SevenZ(String),
    #[error("Unsupported archive format")]
    UnsupportedFormat,
    #[error("Invalid UTF-8 in filename")]
    InvalidUtf8,
}

pub struct ArchiveExtractor;

impl ArchiveExtractor {
    /// Extract an archive to a destination directory without progress callback
    #[allow(dead_code)]
    pub fn extract<P: AsRef<Path>, Q: AsRef<Path>>(
        archive_path: P,
        destination: Q,
    ) -> Result<Vec<PathBuf>, ArchiveError> {
        Self::extract_with_progress(archive_path, destination, |_, _| {})
    }

    /// Extract an archive to a destination directory with progress callback
    /// Callback receives (current_index, total_count)
    pub fn extract_with_progress<P: AsRef<Path>, Q: AsRef<Path>, F>(
        archive_path: P,
        destination: Q,
        progress_callback: F,
    ) -> Result<Vec<PathBuf>, ArchiveError>
    where
        F: FnMut(usize, usize),
    {
        let archive_path = archive_path.as_ref();
        let destination = destination.as_ref();

        // Create destination directory if it doesn't exist
        fs::create_dir_all(destination)?;

        // Determine format by extension
        let extension = archive_path
            .extension()
            .and_then(|ext| ext.to_str())
            .ok_or(ArchiveError::UnsupportedFormat)?
            .to_lowercase();

        match extension.as_str() {
            "zip" => Self::extract_zip_with_progress(archive_path, destination, progress_callback),
            "7z" => Self::extract_7z_with_progress(archive_path, destination, progress_callback),
            _ => Err(ArchiveError::UnsupportedFormat),
        }
    }

    /// Extract ZIP archive with progress callback
    fn extract_zip_with_progress<P: AsRef<Path>, Q: AsRef<Path>, F>(
        archive_path: P,
        destination: Q,
        mut progress_callback: F,
    ) -> Result<Vec<PathBuf>, ArchiveError>
    where
        F: FnMut(usize, usize),
    {
        let file = File::open(archive_path)?;
        let reader = BufReader::new(file);
        let mut archive = zip::ZipArchive::new(reader)?;
        let mut extracted_files = Vec::new();
        let total_files = archive.len();

        for i in 0..total_files {
            progress_callback(i, total_files);

            let mut file = archive.by_index(i)?;
            let file_path = Self::sanitize_path(file.name())?;
            let output_path = destination.as_ref().join(&file_path);

            if file.is_dir() {
                fs::create_dir_all(&output_path)?;
            } else {
                // Create parent directories if they don't exist
                if let Some(parent) = output_path.parent() {
                    fs::create_dir_all(parent)?;
                }

                let mut output_file = File::create(&output_path)?;
                io::copy(&mut file, &mut output_file)?;
                extracted_files.push(output_path.clone());
            }

            // Set permissions on Unix systems
            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                if let Some(mode) = file.unix_mode() {
                    let permissions = std::fs::Permissions::from_mode(mode);
                    let _ = fs::set_permissions(&output_path, permissions);
                }
            }
        }

        progress_callback(total_files, total_files);
        Ok(extracted_files)
    }

    /// Extract 7z archive with progress callback
    fn extract_7z_with_progress<P: AsRef<Path>, Q: AsRef<Path>, F>(
        archive_path: P,
        destination: Q,
        mut progress_callback: F,
    ) -> Result<Vec<PathBuf>, ArchiveError>
    where
        F: FnMut(usize, usize),
    {
        use sevenz_rust::*;

        let mut sz_archive = SevenZReader::open(archive_path, Password::empty())
            .map_err(|e| ArchiveError::SevenZ(format!("Failed to open 7z archive: {:?}", e)))?;

        let destination = destination.as_ref();
        let mut extracted_files = Vec::new();
        let total_count = sz_archive.archive().files.len();
        let mut current_index = 0;

        sz_archive.for_each_entries(|entry, reader| -> Result<bool, Error> {
            progress_callback(current_index, total_count);
            current_index += 1;

            let file_path = match Self::sanitize_path(&entry.name) {
                Ok(path) => path,
                Err(e) => return Err(Error::other(format!("Path sanitization error: {}", e))),
            };

            let output_path = destination.join(&file_path);

            if entry.is_directory() {
                if let Err(e) = fs::create_dir_all(&output_path) {
                    return Err(Error::other(format!("Failed to create directory: {}", e)));
                }
            } else {
                // Create parent directories if they don't exist
                if let Some(parent) = output_path.parent() {
                    if let Err(e) = fs::create_dir_all(parent) {
                        return Err(Error::other(format!("Failed to create parent directory: {}", e)));
                    }
                }

                match File::create(&output_path) {
                    Ok(mut output_file) => {
                        let mut buffer = Vec::new();
                        if let Err(e) = reader.read_to_end(&mut buffer) {
                            return Err(Error::other(format!("Failed to read entry: {}", e)));
                        }
                        if let Err(e) = output_file.write_all(&buffer) {
                            return Err(Error::other(format!("Failed to write file: {}", e)));
                        }
                        extracted_files.push(output_path);
                    }
                    Err(e) => return Err(Error::other(format!("Failed to create file: {}", e))),
                }
            }

            Ok(true) // Continue processing
        }).map_err(|e| ArchiveError::SevenZ(format!("Extraction failed: {:?}", e)))?;

        progress_callback(total_count, total_count);
        Ok(extracted_files)
    }

    /// Sanitize file paths to prevent directory traversal attacks
    fn sanitize_path(path: &str) -> Result<PathBuf, ArchiveError> {
        let path = PathBuf::from(path);
        let mut components = Vec::new();

        for component in path.components() {
            match component {
                std::path::Component::Normal(name) => {
                    components.push(name.to_str().ok_or(ArchiveError::InvalidUtf8)?);
                }
                std::path::Component::CurDir => {
                    // Skip current directory references
                }
                std::path::Component::ParentDir => {
                    // Remove parent directory references for security
                    if !components.is_empty() {
                        components.pop();
                    }
                }
                _ => {
                    // Skip other components like root directory
                }
            }
        }

        if components.is_empty() {
            return Err(ArchiveError::UnsupportedFormat);
        }

        Ok(components.iter().collect())
    }
}
